Thank you for installing the pgvector chart!

Release name: {{ .Release.Name }}
Namespace: {{ .Release.Namespace }}

Access endpoints:
  - PostgreSQL primary service: `{{ include "pgvector.fullname" . }}-postgresql-master.{{ .Release.Namespace }}.svc.cluster.local:5432`
{{- if gt (int .Values.postgresql.replica.replicaCount) 0 }}
  - PostgreSQL replica service: `{{ include "pgvector.fullname" . }}-postgresql-replica.{{ .Release.Namespace }}.svc.cluster.local:5432`
{{- end }}
{{- if .Values.postgresql.pgbouncer.enabled }}
  - PgBouncer pooler: `{{ include "pgvector.fullname" . }}-pgbouncer.{{ .Release.Namespace }}.svc.cluster.local:{{ .Values.postgresql.pgbouncer.service.port }}`
{{- end }}
{{- if .Values.postgresql.haproxy.enabled }}
  - HAProxy endpoint: `{{ include "pgvector.fullname" . }}-haproxy.{{ .Release.Namespace }}.svc.cluster.local:{{ .Values.postgresql.haproxy.service.port }}`
    {{- if .Values.postgresql.pgbouncer.enabled }}
    HAProxy routes traffic through PgBouncer before reaching PostgreSQL.
    {{- else }}
    HAProxy routes directly to the PostgreSQL master{{- if gt .Values.postgresql.replica.replicaCount 0 }} and replicas{{- end }}.
    {{- end }}
{{- end }}

Credentials are stored in the secret `{{ include "pgvector.postgresql.secretName" . }}`.
 Retrieve the generated password with:

  kubectl get secret {{ include "pgvector.postgresql.secretName" . }} \
    --namespace {{ .Release.Namespace }} \
    -o jsonpath='{.data.postgres-password}' | base64 --decode && echo

Primary connection string:
  kubectl get secret {{ include "pgvector.postgresql.urlSecretName" . }} \
    --namespace {{ .Release.Namespace }} \
    -o jsonpath='{.data.postgres-url}' | base64 --decode && echo

Refer to the README for scaling guidance, value overrides, and optional component usage.
